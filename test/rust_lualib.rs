/* automatically generated by rust-bindgen */

use core::libc::*;
pub type Struct_lua_State = c_void;
pub type lua_State = Struct_lua_State;
pub type lua_CFunction = *u8;
pub type lua_Reader = *u8;
pub type lua_Writer = *u8;
pub type lua_Alloc = *u8;
pub type lua_Number = c_double;
pub type lua_Integer = ptrdiff_t;
pub type lua_Unsigned = c_uint;
//pub type lua_Debug = Struct_lua_Debug;
pub type lua_Hook = *u8;
//pub struct Struct_lua_Debug {
//    pub event: c_int,
//    pub name: *c_schar,
//    pub namewhat: *c_schar,
//    pub what: *c_schar,
//    pub source: *c_schar,
//    pub currentline: c_int,
//    pub linedefined: c_int,
//    pub lastlinedefined: c_int,
//    pub nups: c_uchar,
//    pub nparams: c_uchar,
//    pub isvararg: c_schar,
//    pub istailcall: c_schar,
//    pub short_src: [c_schar * 60],
//    pub i_ci: *Struct_CallInfo,
//}
#[link_args = "-llua"]
pub extern "C" {
    fn lua_newstate(++f: lua_Alloc, ++ud: *c_void) -> *lua_State;
    fn lua_close(++L: *lua_State);
    fn lua_newthread(++L: *lua_State) -> *lua_State;
    fn lua_atpanic(++L: *lua_State, ++panicf: lua_CFunction) -> lua_CFunction;
    fn lua_version(++L: *lua_State) -> *lua_Number;
    fn lua_absindex(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_gettop(++L: *lua_State) -> c_int;
    fn lua_settop(++L: *lua_State, ++idx: c_int);
    fn lua_pushvalue(++L: *lua_State, ++idx: c_int);
    fn lua_remove(++L: *lua_State, ++idx: c_int);
    fn lua_insert(++L: *lua_State, ++idx: c_int);
    fn lua_replace(++L: *lua_State, ++idx: c_int);
    fn lua_copy(++L: *lua_State, ++fromidx: c_int, ++toidx: c_int);
    fn lua_checkstack(++L: *lua_State, ++sz: c_int) -> c_int;
    fn lua_xmove(++from: *lua_State, ++to: *lua_State, ++n: c_int);
    fn lua_isnumber(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_isstring(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_iscfunction(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_isuserdata(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_type(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_typename(++L: *lua_State, ++tp: c_int) -> *c_schar;
    fn lua_tonumberx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Number;
    fn lua_tointegerx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Integer;
    fn lua_tounsignedx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Unsigned;
    fn lua_toboolean(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_tolstring(++L: *lua_State, ++idx: c_int, ++len: *size_t) ->
     *c_schar;
    fn lua_rawlen(++L: *lua_State, ++idx: c_int) -> size_t;
    fn lua_tocfunction(++L: *lua_State, ++idx: c_int) -> lua_CFunction;
    fn lua_touserdata(++L: *lua_State, ++idx: c_int) -> *c_void;
    fn lua_tothread(++L: *lua_State, ++idx: c_int) -> *lua_State;
    fn lua_topointer(++L: *lua_State, ++idx: c_int) -> *c_void;
    fn lua_arith(++L: *lua_State, ++op: c_int);
    fn lua_rawequal(++L: *lua_State, ++idx1: c_int, ++idx2: c_int) -> c_int;
    fn lua_compare(++L: *lua_State, ++idx1: c_int, ++idx2: c_int, ++op: c_int)
     -> c_int;
    fn lua_pushnil(++L: *lua_State);
    fn lua_pushnumber(++L: *lua_State, ++n: lua_Number);
    fn lua_pushinteger(++L: *lua_State, ++n: lua_Integer);
    fn lua_pushunsigned(++L: *lua_State, ++n: lua_Unsigned);
    fn lua_pushlstring(++L: *lua_State, ++s: *c_schar, ++l: size_t) ->
     *c_schar;
    fn lua_pushstring(++L: *lua_State, ++s: *c_schar) -> *c_schar;
//    fn lua_pushvfstring(++L: *lua_State, ++fmt: *c_schar,
//                        ++argp: *__va_list_tag) -> *c_schar;
    fn lua_pushfstring(++L: *lua_State, ++fmt: *c_schar) -> *c_schar;
    fn lua_pushcclosure(++L: *lua_State, ++_fn: lua_CFunction, ++n: c_int);
    fn lua_pushboolean(++L: *lua_State, ++b: c_int);
    fn lua_pushlightuserdata(++L: *lua_State, ++p: *c_void);
    fn lua_pushthread(++L: *lua_State) -> c_int;
    fn lua_getglobal(++L: *lua_State, ++var: *c_schar);
    fn lua_gettable(++L: *lua_State, ++idx: c_int);
    fn lua_getfield(++L: *lua_State, ++idx: c_int, ++k: *c_schar);
    fn lua_rawget(++L: *lua_State, ++idx: c_int);
    fn lua_rawgeti(++L: *lua_State, ++idx: c_int, ++n: c_int);
    fn lua_rawgetp(++L: *lua_State, ++idx: c_int, ++p: *c_void);
    fn lua_createtable(++L: *lua_State, ++narr: c_int, ++nrec: c_int);
    fn lua_newuserdata(++L: *lua_State, ++sz: size_t) -> *c_void;
    fn lua_getmetatable(++L: *lua_State, ++objindex: c_int) -> c_int;
    fn lua_getuservalue(++L: *lua_State, ++idx: c_int);
    fn lua_setglobal(++L: *lua_State, ++var: *c_schar);
    fn lua_settable(++L: *lua_State, ++idx: c_int);
    fn lua_setfield(++L: *lua_State, ++idx: c_int, ++k: *c_schar);
    fn lua_rawset(++L: *lua_State, ++idx: c_int);
    fn lua_rawseti(++L: *lua_State, ++idx: c_int, ++n: c_int);
    fn lua_rawsetp(++L: *lua_State, ++idx: c_int, ++p: *c_void);
    fn lua_setmetatable(++L: *lua_State, ++objindex: c_int) -> c_int;
    fn lua_setuservalue(++L: *lua_State, ++idx: c_int);
    fn lua_callk(++L: *lua_State, ++nargs: c_int, ++nresults: c_int,
                 ++ctx: c_int, ++k: lua_CFunction);
    fn lua_getctx(++L: *lua_State, ++ctx: *c_int) -> c_int;
    fn lua_pcallk(++L: *lua_State, ++nargs: c_int, ++nresults: c_int,
                  ++errfunc: c_int, ++ctx: c_int, ++k: lua_CFunction) ->
     c_int;
    fn lua_load(++L: *lua_State, ++reader: lua_Reader, ++dt: *c_void,
                ++chunkname: *c_schar, ++mode: *c_schar) -> c_int;
    fn lua_dump(++L: *lua_State, ++writer: lua_Writer, ++data: *c_void) ->
     c_int;
    fn lua_yieldk(++L: *lua_State, ++nresults: c_int, ++ctx: c_int,
                  ++k: lua_CFunction) -> c_int;
    fn lua_resume(++L: *lua_State, ++from: *lua_State, ++narg: c_int) ->
     c_int;
    fn lua_status(++L: *lua_State) -> c_int;
    fn lua_gc(++L: *lua_State, ++what: c_int, ++data: c_int) -> c_int;
    fn lua_error(++L: *lua_State) -> c_int;
    fn lua_next(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_concat(++L: *lua_State, ++n: c_int);
    fn lua_len(++L: *lua_State, ++idx: c_int);
    fn lua_getallocf(++L: *lua_State, ++ud: **c_void) -> lua_Alloc;
    fn lua_setallocf(++L: *lua_State, ++f: lua_Alloc, ++ud: *c_void);
//    fn lua_getstack(++L: *lua_State, ++level: c_int, ++ar: *lua_Debug) ->
//     c_int;
//    fn lua_getinfo(++L: *lua_State, ++what: *c_schar, ++ar: *lua_Debug) ->
//     c_int;
//    fn lua_getlocal(++L: *lua_State, ++ar: *lua_Debug, ++n: c_int) ->
//     *c_schar;
//    fn lua_setlocal(++L: *lua_State, ++ar: *lua_Debug, ++n: c_int) ->
//     *c_schar;
    fn lua_getupvalue(++L: *lua_State, ++funcindex: c_int, ++n: c_int) ->
     *c_schar;
    fn lua_setupvalue(++L: *lua_State, ++funcindex: c_int, ++n: c_int) ->
     *c_schar;
    fn lua_upvalueid(++L: *lua_State, ++fidx: c_int, ++n: c_int) -> *c_void;
    fn lua_upvaluejoin(++L: *lua_State, ++fidx1: c_int, ++n1: c_int,
                       ++fidx2: c_int, ++n2: c_int);
    fn lua_sethook(++L: *lua_State, ++func: lua_Hook, ++mask: c_int,
                   ++count: c_int) -> c_int;
    fn lua_gethook(++L: *lua_State) -> lua_Hook;
    fn lua_gethookmask(++L: *lua_State) -> c_int;
    fn lua_gethookcount(++L: *lua_State) -> c_int;
    fn luaopen_base(++L: *lua_State) -> c_int;
    fn luaopen_coroutine(++L: *lua_State) -> c_int;
    fn luaopen_table(++L: *lua_State) -> c_int;
    fn luaopen_io(++L: *lua_State) -> c_int;
    fn luaopen_os(++L: *lua_State) -> c_int;
    fn luaopen_string(++L: *lua_State) -> c_int;
    fn luaopen_bit32(++L: *lua_State) -> c_int;
    fn luaopen_math(++L: *lua_State) -> c_int;
    fn luaopen_debug(++L: *lua_State) -> c_int;
    fn luaopen_package(++L: *lua_State) -> c_int;
    fn luaL_openlibs(++L: *lua_State);
}
