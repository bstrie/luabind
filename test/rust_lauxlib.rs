/* automatically generated by rust-bindgen */

use core::libc::*;
pub type Struct_lua_State = c_void;
pub type lua_State = Struct_lua_State;
pub type lua_CFunction = *u8;
pub type lua_Reader = *u8;
pub type lua_Writer = *u8;
pub type lua_Alloc = *u8;
pub type lua_Number = c_double;
pub type lua_Integer = ptrdiff_t;
pub type lua_Unsigned = c_uint;
//pub type lua_Debug = Struct_lua_Debug;
pub type lua_Hook = *u8;
//pub struct Struct_lua_Debug {
//    pub event: c_int,
//    pub name: *c_schar,
//    pub namewhat: *c_schar,
//    pub what: *c_schar,
//    pub source: *c_schar,
//    pub currentline: c_int,
//    pub linedefined: c_int,
//    pub lastlinedefined: c_int,
//    pub nups: c_uchar,
//    pub nparams: c_uchar,
//    pub isvararg: c_schar,
//    pub istailcall: c_schar,
//    pub short_src: [c_schar * 60],
//    pub i_ci: *Struct_CallInfo,
//}
pub struct Struct_luaL_Reg {
    pub name: *c_schar,
    pub func: lua_CFunction,
}
pub type luaL_Reg = Struct_luaL_Reg;
pub struct Struct_luaL_Buffer {
    pub b: *c_schar,
    pub size: size_t,
    pub n: size_t,
    pub L: *lua_State,
    pub initb: [c_schar * 8192],
}
pub type luaL_Buffer = Struct_luaL_Buffer;
pub struct Struct_luaL_Stream {
    pub f: *FILE,
    pub closef: lua_CFunction,
}
pub type luaL_Stream = Struct_luaL_Stream;
#[link_args = "-llua"]
pub extern "C" {
    fn lua_newstate(++f: lua_Alloc, ++ud: *c_void) -> *lua_State;
    fn lua_close(++L: *lua_State);
    fn lua_newthread(++L: *lua_State) -> *lua_State;
    fn lua_atpanic(++L: *lua_State, ++panicf: lua_CFunction) -> lua_CFunction;
    fn lua_version(++L: *lua_State) -> *lua_Number;
    fn lua_absindex(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_gettop(++L: *lua_State) -> c_int;
    fn lua_settop(++L: *lua_State, ++idx: c_int);
    fn lua_pushvalue(++L: *lua_State, ++idx: c_int);
    fn lua_remove(++L: *lua_State, ++idx: c_int);
    fn lua_insert(++L: *lua_State, ++idx: c_int);
    fn lua_replace(++L: *lua_State, ++idx: c_int);
    fn lua_copy(++L: *lua_State, ++fromidx: c_int, ++toidx: c_int);
    fn lua_checkstack(++L: *lua_State, ++sz: c_int) -> c_int;
    fn lua_xmove(++from: *lua_State, ++to: *lua_State, ++n: c_int);
    fn lua_isnumber(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_isstring(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_iscfunction(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_isuserdata(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_type(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_typename(++L: *lua_State, ++tp: c_int) -> *c_schar;
    fn lua_tonumberx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Number;
    fn lua_tointegerx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Integer;
    fn lua_tounsignedx(++L: *lua_State, ++idx: c_int, ++isnum: *c_int) ->
     lua_Unsigned;
    fn lua_toboolean(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_tolstring(++L: *lua_State, ++idx: c_int, ++len: *size_t) ->
     *c_schar;
    fn lua_rawlen(++L: *lua_State, ++idx: c_int) -> size_t;
    fn lua_tocfunction(++L: *lua_State, ++idx: c_int) -> lua_CFunction;
    fn lua_touserdata(++L: *lua_State, ++idx: c_int) -> *c_void;
    fn lua_tothread(++L: *lua_State, ++idx: c_int) -> *lua_State;
    fn lua_topointer(++L: *lua_State, ++idx: c_int) -> *c_void;
    fn lua_arith(++L: *lua_State, ++op: c_int);
    fn lua_rawequal(++L: *lua_State, ++idx1: c_int, ++idx2: c_int) -> c_int;
    fn lua_compare(++L: *lua_State, ++idx1: c_int, ++idx2: c_int, ++op: c_int)
     -> c_int;
    fn lua_pushnil(++L: *lua_State);
    fn lua_pushnumber(++L: *lua_State, ++n: lua_Number);
    fn lua_pushinteger(++L: *lua_State, ++n: lua_Integer);
    fn lua_pushunsigned(++L: *lua_State, ++n: lua_Unsigned);
    fn lua_pushlstring(++L: *lua_State, ++s: *c_schar, ++l: size_t) ->
     *c_schar;
    fn lua_pushstring(++L: *lua_State, ++s: *c_schar) -> *c_schar;
//    fn lua_pushvfstring(++L: *lua_State, ++fmt: *c_schar,
//                        ++argp: *__va_list_tag) -> *c_schar;
    fn lua_pushfstring(++L: *lua_State, ++fmt: *c_schar) -> *c_schar;
    fn lua_pushcclosure(++L: *lua_State, ++_fn: lua_CFunction, ++n: c_int);
    fn lua_pushboolean(++L: *lua_State, ++b: c_int);
    fn lua_pushlightuserdata(++L: *lua_State, ++p: *c_void);
    fn lua_pushthread(++L: *lua_State) -> c_int;
    fn lua_getglobal(++L: *lua_State, ++var: *c_schar);
    fn lua_gettable(++L: *lua_State, ++idx: c_int);
    fn lua_getfield(++L: *lua_State, ++idx: c_int, ++k: *c_schar);
    fn lua_rawget(++L: *lua_State, ++idx: c_int);
    fn lua_rawgeti(++L: *lua_State, ++idx: c_int, ++n: c_int);
    fn lua_rawgetp(++L: *lua_State, ++idx: c_int, ++p: *c_void);
    fn lua_createtable(++L: *lua_State, ++narr: c_int, ++nrec: c_int);
    fn lua_newuserdata(++L: *lua_State, ++sz: size_t) -> *c_void;
    fn lua_getmetatable(++L: *lua_State, ++objindex: c_int) -> c_int;
    fn lua_getuservalue(++L: *lua_State, ++idx: c_int);
    fn lua_setglobal(++L: *lua_State, ++var: *c_schar);
    fn lua_settable(++L: *lua_State, ++idx: c_int);
    fn lua_setfield(++L: *lua_State, ++idx: c_int, ++k: *c_schar);
    fn lua_rawset(++L: *lua_State, ++idx: c_int);
    fn lua_rawseti(++L: *lua_State, ++idx: c_int, ++n: c_int);
    fn lua_rawsetp(++L: *lua_State, ++idx: c_int, ++p: *c_void);
    fn lua_setmetatable(++L: *lua_State, ++objindex: c_int) -> c_int;
    fn lua_setuservalue(++L: *lua_State, ++idx: c_int);
    fn lua_callk(++L: *lua_State, ++nargs: c_int, ++nresults: c_int,
                 ++ctx: c_int, ++k: lua_CFunction);
    fn lua_getctx(++L: *lua_State, ++ctx: *c_int) -> c_int;
    fn lua_pcallk(++L: *lua_State, ++nargs: c_int, ++nresults: c_int,
                  ++errfunc: c_int, ++ctx: c_int, ++k: lua_CFunction) ->
     c_int;
    fn lua_load(++L: *lua_State, ++reader: lua_Reader, ++dt: *c_void,
                ++chunkname: *c_schar, ++mode: *c_schar) -> c_int;
    fn lua_dump(++L: *lua_State, ++writer: lua_Writer, ++data: *c_void) ->
     c_int;
    fn lua_yieldk(++L: *lua_State, ++nresults: c_int, ++ctx: c_int,
                  ++k: lua_CFunction) -> c_int;
    fn lua_resume(++L: *lua_State, ++from: *lua_State, ++narg: c_int) ->
     c_int;
    fn lua_status(++L: *lua_State) -> c_int;
    fn lua_gc(++L: *lua_State, ++what: c_int, ++data: c_int) -> c_int;
    fn lua_error(++L: *lua_State) -> c_int;
    fn lua_next(++L: *lua_State, ++idx: c_int) -> c_int;
    fn lua_concat(++L: *lua_State, ++n: c_int);
    fn lua_len(++L: *lua_State, ++idx: c_int);
    fn lua_getallocf(++L: *lua_State, ++ud: **c_void) -> lua_Alloc;
    fn lua_setallocf(++L: *lua_State, ++f: lua_Alloc, ++ud: *c_void);
//    fn lua_getstack(++L: *lua_State, ++level: c_int, ++ar: *lua_Debug) ->
//     c_int;
//    fn lua_getinfo(++L: *lua_State, ++what: *c_schar, ++ar: *lua_Debug) ->
//     c_int;
//    fn lua_getlocal(++L: *lua_State, ++ar: *lua_Debug, ++n: c_int) ->
//     *c_schar;
//    fn lua_setlocal(++L: *lua_State, ++ar: *lua_Debug, ++n: c_int) ->
//     *c_schar;
    fn lua_getupvalue(++L: *lua_State, ++funcindex: c_int, ++n: c_int) ->
     *c_schar;
    fn lua_setupvalue(++L: *lua_State, ++funcindex: c_int, ++n: c_int) ->
     *c_schar;
    fn lua_upvalueid(++L: *lua_State, ++fidx: c_int, ++n: c_int) -> *c_void;
    fn lua_upvaluejoin(++L: *lua_State, ++fidx1: c_int, ++n1: c_int,
                       ++fidx2: c_int, ++n2: c_int);
    fn lua_sethook(++L: *lua_State, ++func: lua_Hook, ++mask: c_int,
                   ++count: c_int) -> c_int;
    fn lua_gethook(++L: *lua_State) -> lua_Hook;
    fn lua_gethookmask(++L: *lua_State) -> c_int;
    fn lua_gethookcount(++L: *lua_State) -> c_int;
    fn luaL_checkversion_(++L: *lua_State, ++ver: lua_Number);
    fn luaL_getmetafield(++L: *lua_State, ++obj: c_int, ++e: *c_schar) ->
     c_int;
    fn luaL_callmeta(++L: *lua_State, ++obj: c_int, ++e: *c_schar) -> c_int;
    fn luaL_tolstring(++L: *lua_State, ++idx: c_int, ++len: *size_t) ->
     *c_schar;
    fn luaL_argerror(++L: *lua_State, ++numarg: c_int, ++extramsg: *c_schar)
     -> c_int;
    fn luaL_checklstring(++L: *lua_State, ++numArg: c_int, ++l: *size_t) ->
     *c_schar;
    fn luaL_optlstring(++L: *lua_State, ++numArg: c_int, ++def: *c_schar,
                       ++l: *size_t) -> *c_schar;
    fn luaL_checknumber(++L: *lua_State, ++numArg: c_int) -> lua_Number;
    fn luaL_optnumber(++L: *lua_State, ++nArg: c_int, ++def: lua_Number) ->
     lua_Number;
    fn luaL_checkinteger(++L: *lua_State, ++numArg: c_int) -> lua_Integer;
    fn luaL_optinteger(++L: *lua_State, ++nArg: c_int, ++def: lua_Integer) ->
     lua_Integer;
    fn luaL_checkunsigned(++L: *lua_State, ++numArg: c_int) -> lua_Unsigned;
    fn luaL_optunsigned(++L: *lua_State, ++numArg: c_int, ++def: lua_Unsigned)
     -> lua_Unsigned;
    fn luaL_checkstack(++L: *lua_State, ++sz: c_int, ++msg: *c_schar);
    fn luaL_checktype(++L: *lua_State, ++narg: c_int, ++t: c_int);
    fn luaL_checkany(++L: *lua_State, ++narg: c_int);
    fn luaL_newmetatable(++L: *lua_State, ++tname: *c_schar) -> c_int;
    fn luaL_setmetatable(++L: *lua_State, ++tname: *c_schar);
    fn luaL_testudata(++L: *lua_State, ++ud: c_int, ++tname: *c_schar) ->
     *c_void;
    fn luaL_checkudata(++L: *lua_State, ++ud: c_int, ++tname: *c_schar) ->
     *c_void;
    fn luaL_where(++L: *lua_State, ++lvl: c_int);
    fn luaL_error(++L: *lua_State, ++fmt: *c_schar) -> c_int;
    fn luaL_checkoption(++L: *lua_State, ++narg: c_int, ++def: *c_schar,
                        ++lst: **c_schar) -> c_int;
    fn luaL_fileresult(++L: *lua_State, ++stat: c_int, ++fname: *c_schar) ->
     c_int;
    fn luaL_execresult(++L: *lua_State, ++stat: c_int) -> c_int;
    fn luaL_ref(++L: *lua_State, ++t: c_int) -> c_int;
    fn luaL_unref(++L: *lua_State, ++t: c_int, ++_ref: c_int);
    fn luaL_loadfilex(++L: *lua_State, ++filename: *c_schar, ++mode: *c_schar)
     -> c_int;
    fn luaL_loadbufferx(++L: *lua_State, ++buff: *c_schar, ++sz: size_t,
                        ++name: *c_schar, ++mode: *c_schar) -> c_int;
    fn luaL_loadstring(++L: *lua_State, ++s: *c_schar) -> c_int;
    fn luaL_newstate() -> *lua_State;
    fn luaL_len(++L: *lua_State, ++idx: c_int) -> c_int;
    fn luaL_gsub(++L: *lua_State, ++s: *c_schar, ++p: *c_schar, ++r: *c_schar)
     -> *c_schar;
    fn luaL_setfuncs(++L: *lua_State, ++l: *luaL_Reg, ++nup: c_int);
    fn luaL_getsubtable(++L: *lua_State, ++idx: c_int, ++fname: *c_schar) ->
     c_int;
    fn luaL_traceback(++L: *lua_State, ++L1: *lua_State, ++msg: *c_schar,
                      ++level: c_int);
    fn luaL_requiref(++L: *lua_State, ++modname: *c_schar,
                     ++openf: lua_CFunction, ++glb: c_int);
    fn luaL_buffinit(++L: *lua_State, ++B: *luaL_Buffer);
    fn luaL_prepbuffsize(++B: *luaL_Buffer, ++sz: size_t) -> *c_schar;
    fn luaL_addlstring(++B: *luaL_Buffer, ++s: *c_schar, ++l: size_t);
    fn luaL_addstring(++B: *luaL_Buffer, ++s: *c_schar);
    fn luaL_addvalue(++B: *luaL_Buffer);
    fn luaL_pushresult(++B: *luaL_Buffer);
    fn luaL_pushresultsize(++B: *luaL_Buffer, ++sz: size_t);
    fn luaL_buffinitsize(++L: *lua_State, ++B: *luaL_Buffer, ++sz: size_t) ->
     *c_schar;
}
