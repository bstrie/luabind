/* automatically generated by rust-bindgen */

use std::libc::*;
pub type Struct_lua_State = c_void;
pub type lua_State = Struct_lua_State;
pub type lua_CFunction = *u8;
pub type lua_Reader = *u8;
pub type lua_Writer = *u8;
pub type lua_Alloc = *u8;
pub type lua_Number = c_double;
pub type lua_Integer = ptrdiff_t;
pub type lua_Debug = Struct_lua_Debug;
pub type lua_Hook = *u8;
pub struct Struct_lua_Debug {
    pub event: c_int,
    pub name: *c_schar,
    pub namewhat: *c_schar,
    pub what: *c_schar,
    pub source: *c_schar,
    pub currentline: c_int,
    pub nups: c_int,
    pub linedefined: c_int,
    pub lastlinedefined: c_int,
    pub short_src: [c_schar, ..60u],
    pub i_ci: c_int,
}
#[link_args = "-lluajit-5.1"]
pub extern "C" {
    fn lua_newstate(f: lua_Alloc, ud: *mut c_void) -> *mut lua_State;
    fn lua_close(L: *mut lua_State);
    fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
    fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction) -> lua_CFunction;
    fn lua_gettop(L: *mut lua_State) -> c_int;
    fn lua_settop(L: *mut lua_State, idx: c_int);
    fn lua_pushvalue(L: *mut lua_State, idx: c_int);
    fn lua_remove(L: *mut lua_State, idx: c_int);
    fn lua_insert(L: *mut lua_State, idx: c_int);
    fn lua_replace(L: *mut lua_State, idx: c_int);
    fn lua_checkstack(L: *mut lua_State, sz: c_int) -> c_int;
    fn lua_xmove(from: *mut lua_State, to: *mut lua_State, n: c_int);
    fn lua_isnumber(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_isstring(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_iscfunction(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_isuserdata(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_type(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_typename(L: *mut lua_State, tp: c_int) -> *c_schar;
    fn lua_equal(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
    fn lua_rawequal(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
    fn lua_lessthan(L: *mut lua_State, idx1: c_int, idx2: c_int) -> c_int;
    fn lua_tonumber(L: *mut lua_State, idx: c_int) -> lua_Number;
    fn lua_tointeger(L: *mut lua_State, idx: c_int) -> lua_Integer;
    fn lua_toboolean(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_tolstring(L: *mut lua_State, idx: c_int, len: *mut size_t) ->
     *c_schar;
    fn lua_objlen(L: *mut lua_State, idx: c_int) -> size_t;
    fn lua_tocfunction(L: *mut lua_State, idx: c_int) -> lua_CFunction;
    fn lua_touserdata(L: *mut lua_State, idx: c_int) -> *mut c_void;
    fn lua_tothread(L: *mut lua_State, idx: c_int) -> *mut lua_State;
    fn lua_topointer(L: *mut lua_State, idx: c_int) -> *c_void;
    fn lua_pushnil(L: *mut lua_State);
    fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
    fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
    fn lua_pushlstring(L: *mut lua_State, s: *c_schar, l: size_t);
    fn lua_pushstring(L: *mut lua_State, s: *c_schar);
//    fn lua_pushvfstring(L: *mut lua_State, fmt: *c_schar,
//                        argp: *mut __va_list_tag) -> *c_schar;
    fn lua_pushfstring(L: *mut lua_State, fmt: *c_schar) -> *c_schar;
    fn lua_pushcclosure(L: *mut lua_State, _fn: lua_CFunction, n: c_int);
    fn lua_pushboolean(L: *mut lua_State, b: c_int);
    fn lua_pushlightuserdata(L: *mut lua_State, p: *mut c_void);
    fn lua_pushthread(L: *mut lua_State) -> c_int;
    fn lua_gettable(L: *mut lua_State, idx: c_int);
    fn lua_getfield(L: *mut lua_State, idx: c_int, k: *c_schar);
    fn lua_rawget(L: *mut lua_State, idx: c_int);
    fn lua_rawgeti(L: *mut lua_State, idx: c_int, n: c_int);
    fn lua_createtable(L: *mut lua_State, narr: c_int, nrec: c_int);
    fn lua_newuserdata(L: *mut lua_State, sz: size_t) -> *mut c_void;
    fn lua_getmetatable(L: *mut lua_State, objindex: c_int) -> c_int;
    fn lua_getfenv(L: *mut lua_State, idx: c_int);
    fn lua_settable(L: *mut lua_State, idx: c_int);
    fn lua_setfield(L: *mut lua_State, idx: c_int, k: *c_schar);
    fn lua_rawset(L: *mut lua_State, idx: c_int);
    fn lua_rawseti(L: *mut lua_State, idx: c_int, n: c_int);
    fn lua_setmetatable(L: *mut lua_State, objindex: c_int) -> c_int;
    fn lua_setfenv(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_call(L: *mut lua_State, nargs: c_int, nresults: c_int);
    fn lua_pcall(L: *mut lua_State, nargs: c_int, nresults: c_int,
                 errfunc: c_int) -> c_int;
    fn lua_cpcall(L: *mut lua_State, func: lua_CFunction, ud: *mut c_void) ->
     c_int;
    fn lua_load(L: *mut lua_State, reader: lua_Reader, dt: *mut c_void,
                chunkname: *c_schar) -> c_int;
    fn lua_dump(L: *mut lua_State, writer: lua_Writer, data: *mut c_void) ->
     c_int;
    fn lua_yield(L: *mut lua_State, nresults: c_int) -> c_int;
    fn lua_resume(L: *mut lua_State, narg: c_int) -> c_int;
    fn lua_status(L: *mut lua_State) -> c_int;
    fn lua_gc(L: *mut lua_State, what: c_int, data: c_int) -> c_int;
    fn lua_error(L: *mut lua_State) -> c_int;
    fn lua_next(L: *mut lua_State, idx: c_int) -> c_int;
    fn lua_concat(L: *mut lua_State, n: c_int);
    fn lua_getallocf(L: *mut lua_State, ud: *mut *mut c_void) -> lua_Alloc;
    fn lua_setallocf(L: *mut lua_State, f: lua_Alloc, ud: *mut c_void);
//    fn lua_setlevel(from: *mut lua_State, to: *mut lua_State);
    fn lua_getstack(L: *mut lua_State, level: c_int, ar: *mut lua_Debug) ->
     c_int;
    fn lua_getinfo(L: *mut lua_State, what: *c_schar, ar: *mut lua_Debug) ->
     c_int;
    fn lua_getlocal(L: *mut lua_State, ar: *lua_Debug, n: c_int) -> *c_schar;
    fn lua_setlocal(L: *mut lua_State, ar: *lua_Debug, n: c_int) -> *c_schar;
    fn lua_getupvalue(L: *mut lua_State, funcindex: c_int, n: c_int) ->
     *c_schar;
    fn lua_setupvalue(L: *mut lua_State, funcindex: c_int, n: c_int) ->
     *c_schar;
    fn lua_sethook(L: *mut lua_State, func: lua_Hook, mask: c_int,
                   count: c_int) -> c_int;
    fn lua_gethook(L: *mut lua_State) -> lua_Hook;
    fn lua_gethookmask(L: *mut lua_State) -> c_int;
    fn lua_gethookcount(L: *mut lua_State) -> c_int;
    fn lua_upvalueid(L: *mut lua_State, idx: c_int, n: c_int) -> *mut c_void;
    fn lua_upvaluejoin(L: *mut lua_State, idx1: c_int, n1: c_int, idx2: c_int,
                       n2: c_int);
    fn lua_loadx(L: *mut lua_State, reader: lua_Reader, dt: *mut c_void,
                 chunkname: *c_schar, mode: *c_schar) -> c_int;
}
